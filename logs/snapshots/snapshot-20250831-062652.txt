## Git Commit
c0136e2b751d2d86c6bb533a0cc319fb86e505e0

## Git Log (last 3)
c0136e2 added the ideas file
83f7a81 have a better azq doc commanbd.
2b1dec9 many many sins.

## Git Diff
diff --git a/bin/azq b/bin/azq
index cd662c5..85e8e6d 100755
--- a/bin/azq
+++ b/bin/azq
@@ -18,7 +18,7 @@ case "$cmd" in
     echo "[azq] Asking ChatGPT with input: $*" 
     echo "---" >> logs/chatlog.md
     echo "USER: $*" >> logs/chatlog.md
-    python - <<'PY'
+    python - "$@" <<'PY'
 from azq.openai_client import client
 import sys, json
 
diff --git a/ideas/BRAINSTORMING.md b/ideas/BRAINSTORMING.md
new file mode 100644
index 0000000..ababf5d
--- /dev/null
+++ b/ideas/BRAINSTORMING.md
@@ -0,0 +1 @@
+s is a place where we can dump some brainstorming ideas. I imagine if this is gonna be a file that gets written and then rewritten and then written again several times I don't think it has to be anything special new or interesting but it is a fun place where we can just dump things. Some of the ideas are gonna be solid gold like the idea of incorporating getinto this process to make it flow a little bit better but some of the ideas are gonna be absolutely crap like what would happen if we get ChatGPT access on the most powerful super computer on campus I feel like there's gonna be some back-and-forth and I'm OK with that but here's our brainstorming file.
diff --git a/ideas/VISION.md b/ideas/VISION.md
new file mode 100644
index 0000000..253bb77
--- /dev/null
+++ b/ideas/VISION.md
@@ -0,0 +1,82 @@
+# 🌌 Vision for azq
+
+azq is more than a CLI to ask ChatGPT — it’s an **experiment in amplifying human creativity through the terminal.**
+
+We believe the terminal is not just a place to run commands, but a place to *think with machines*. azq aims to make that experience richer, smarter, and more rewarding.  
+Below are the guiding ideas that shape our direction.
+
+---
+
+## ✨ Core Mission
+- Provide a **fast, text-first interface** to powerful AI models.
+- Capture **context from the repo and git history** so questions are always grounded in the real project state.
+- Build an **ever-growing knowledge base** (logs, docs, manpages, diffs) that evolves alongside the codebase.
+- Create tools that **teach as they go**, turning every session into a mini-lesson or a seed for future training.
+
+---
+
+## 🚀 Big Ideas
+
+### 1. Repo-Aware Conversations
+- Every `azq ask` should include:
+  - The current **git commit hash** (project state).
+  - Optionally, the **git diff** from the last commit.
+  - Key files (README, requirements, recent changes).
+- This anchors questions/answers in time, and allows for reproducibility.
+
+### 2. Context Snapshots
+- Automatically gather:
+  - File tree
+  - README + requirements
+  - Relevant code snippets
+- Ship this alongside the question so the AI can “see” what the repo looks like *right now*.
+
+### 3. Doc Mode
+- Integrate **manpages** and **Python docstrings** directly into the workflow.
+- Build a repo-wide documentation archive:
+  - Concise index of functions/commands used.
+  - Full-text manpages stored in `logs/docs/`.
+- Goal: richer answers today, training material for better models tomorrow.
+
+### 4. Teaching Mode
+- Scrape the repo for all its moving parts (files, imports, tools, styles).
+- Auto-generate:
+  - A **book-style walkthrough** (Hello World → Finished Project).
+  - Scripts for **narrated video lessons**.
+- Lean into creativity (talking origami dinosaur narrator, Attila the Hun Python crash course, etc.).
+
+### 5. Ghost Completion
+- Experiment with **“paragraph-level completions”** like Copilot, but lightweight:
+  - First in terminal (fzf-like preview).
+  - Later in VS Code integration.
+- Dream: combine azq context-awareness with Copilot’s fluid typing assistance.
+
+### 6. Rewarding CLI Experience
+- The terminal is sacred. GUI is for mortals.  
+- azq should reward power users with:
+  - Clever badges/titles (*azq adept*, *wizard of pipes*).
+  - Easter eggs in responses.
+  - Logging that feels like a story of progress.
+
+---
+
+## 🌱 Why This Matters
+- Every repo becomes not just a project, but a **living dataset**.
+- Every question/answer pair is **anchored in history**.
+- azq could eventually help train **better domain-specific models** by providing a stream of:
+  - Context (git state, diffs, docs).
+  - Dialogue (questions + answers).
+  - Reflections (ideas folder, vision notes).
+
+---
+
+## 🛠 Next Steps
+- Stabilize `ask`, `doc`, and `import` commands.
+- Add `git log` + `git diff` integration.
+- Experiment with “context snapshot” files on each question.
+- Continue capturing ideas in `ideas/` — no thought too wild.
+
+---
+
+*azq is the command line whisperer. May it grow weird and wonderful.*
+
diff --git a/ideas/context_snapshot.md b/ideas/context_snapshot.md
new file mode 100644
index 0000000..54ec36f
--- /dev/null
+++ b/ideas/context_snapshot.md
@@ -0,0 +1 @@
+The general idea is that before sending the question ask con generate a summary of the repo that includes all of its files, all of its recent diffs and also maybe a read me file along with the requirements and any other Nuggets goodies or little Easter eggs that we wanna incorporate into every single commit that we runthis provides a context file that gets passed into the assistant along with the users query that lets the agent have a much fuller view of what's going on inside of the machine, and it helps the answers be very much more specific so that the interface can say OK given that your repo has a file called this we're going to suggest that the idea here is if we're uploading it as a text file we can upload possibly millions of lines of code and other context and things like that, including previous questions previous answers get information as well as other performance or other information like that and let the agent have a much fuller view of what it is that we're trying to do the goal of this is also to help provide a more robust framework for the large language model so that we can have more well trained large language models in the future.
diff --git a/ideas/ghost_completion.md b/ideas/ghost_completion.md
new file mode 100644
index 0000000..7765eed
--- /dev/null
+++ b/ideas/ghost_completion.md
@@ -0,0 +1 @@
+d a conversation with a friend tonight and it made me think about the fact that we can do things inside visual studio code slightly differently. I was sitting on in the restroom, getting ready to make a bath for one of my daughters and I was thinking about how when this gets ready that we can just be mashing fingers on the keyboard kind of like we did and that's when I came up with this idea of ghost completion. I think ghost completion is a later phase. I think it's a integration with visual studio code once we get there and I think ask shirt certainly should be integrated with visual studio code, but I think possibly the smarter move would be to actually just work with get hub copilot and teach them how we're doing ask and just ask for them to do the integration I don't think that it's anything special. I don't think it's anything unique but I think it is going to change how we are viewing our interactions with ChatGPT and things linow the way that they're doing it might be a little too heavy for us to do the things that we're doing your password?
diff --git a/ideas/manpages_integration.md b/ideas/manpages_integration.md
new file mode 100644
index 0000000..4bf4168
--- /dev/null
+++ b/ideas/manpages_integration.md
@@ -0,0 +1 @@
+The idea that we had here was that we could look at code as it's being written and whenever we have code that shows up in the body of code make sure that we're grabbing the man page for that piece of code and sticking it into a documentation list and then making sure that we have the documentation for everything that's on that list insidea documentation file. The idea being we have a concise list of here the principles then we have a longer body of text that says here's the man pages for all those principles. The goal of this was to support better responses from the large language model so that they can have the relevant and here's how they see the world today based off of these commands. The goal of this was to try to get better responses from the large language models and also possibly provide training for future large language models that we can possibly improve in Taylor more towards this new way of or possibly just different way that's more verbose into dealing with the large language models from the fan line environment.:
diff --git a/ideas/readme-badge.md b/ideas/readme-badge.md
new file mode 100644
index 0000000..179ac69
--- /dev/null
+++ b/ideas/readme-badge.md
@@ -0,0 +1 @@
+ChatGPT had a really fun idea called adding a read me badge. This is supposed to basically be a little asking or emoji banner at the top of the main read me.MD that gets added so that it can say something like powered by ask, which is spelled AZQ so every repo you use it feels like it's been branded I think ChatGPT had A really interesting idea and it's fun and it's also a way for us to realize when we're looking at one repo that happens toeverything that has been improved by the process of working with ChatGPT as well as ask and I think it's important for other humans to realize all the people and all the history that has gone into making a repo. I think this is a fun idea, but I'm not sure how to incorporate it yet, but it was a great suggestion by ChatGPT.
diff --git a/ideas/teaching_mode.md b/ideas/teaching_mode.md
new file mode 100644
index 0000000..39fbed9
--- /dev/null
+++ b/ideas/teaching_mode.md
@@ -0,0 +1 @@
+dea that we had here was a teaching mode that would go and look inside a repository and look inside a file structure and look at the commands that are being used. Look at the programming language that's being used, and then the tools aspects, styles, and designs of the programming language, and then basically scrapes the entire project and says all right first of all here's the list of all the things that need to be figured out now that we've got the list of things that need to be figured out. Here's all the documentation that goes with the things that need to be figured out and now that we've got all the documentation all the list of things that need to get figured out let's take all of that and go look at the structure of how other books have been written and what might work well and then ask the question of how do we group everything together so that it makes the most cohesive sense and then work backwards from the end product to the beginning of hello world and come up with the process that basically teaches the student step-by-step the key components that they're going to add in such a way that they start with hello world, but they end with a working project and they incorporate things like unit testing and source code management and effective use of this new ask tool effectively to help it be more help the student be more successful. We even talked about silly things like possibly having a talking paper origami dinosaur to do voice narration and do a video presentation in what feels like a live classroom or feels like a chat, where you can chat back-and-forth with a talking paper dinosaur these are all just ideas, but we're gonna go ahead and capture that right now.
diff --git a/ideas/version-aware-question-and-answer.md b/ideas/version-aware-question-and-answer.md
new file mode 100644
index 0000000..27d629b
--- /dev/null
+++ b/ideas/version-aware-question-and-answer.md
@@ -0,0 +1 @@
+The idea here was to have a way to send in the current get commit hash and optionally to get diff from the last commit. This is supposed to just provide more context for the large language model to see what's going on with the code and with the project in general and see what progression has been made this way every question and answer is also anchored in the exact repost state date and time and the user has some context on what's going on. This also could be pretty beneficial for helping us. Also suggest suggest get commands so that we can have more meaningful more useful get commands that are also going to work better with a large language model because in theory eventually we're gonna screw things up and we're gonna need to go back in time to a previous commit and so it's gonna be beneficial for the large language model to have meaningful hashes that they can pull out more readily and actually say OK yep that is something that I'm able to process faster more effectively. Let's go do . It's also useful for adding auditing for reproduceability and later training of the large language models for what has changed versus what was asked for this is going to hopefully help train them more effectively and help them be more streamlined and more effective.
diff --git a/logs/chatlog.md b/logs/chatlog.md
index e5504d2..dd71300 100644
--- a/logs/chatlog.md
+++ b/logs/chatlog.md
@@ -10,3 +10,6 @@ ASSISTANT: Hello! How can I assist you today?
 ---
 USER: What is 2+2?
 ASSISTANT: Hello! How can I assist you today?
+---
+USER: What is 2+2?
+ASSISTANT: 2 + 2 equals 4.

## File Tree
.:
azq
azq_env
bin
debian
docs
hello.txt
home
ideas
LICENSE
logs
README.md
requirements.txt
rpm
tests

./azq:
context_snapshot.py
import_convo.py
openai_client.py
partse_convo.py
__pycache__

./azq/__pycache__:
context_snapshot.cpython-311.pyc
openai_client.cpython-311.pyc

./azq_env:
bin
include
lib
lib64
pyvenv.cfg

./azq_env/bin:
activate
activate.csh
activate.fish
Activate.ps1
distro
dotenv
httpx
openai
pip
pip3
pip3.11
pygmentize
py.test
pytest
python
python3
python3.11
tqdm

./azq_env/include:
python3.11

./azq_env/include/python3.11:

./azq_env/lib:
python3.11

./azq_env/lib/python3.11:
site-packages

./azq_env/lib/python3.11/site-packages:
annotated_types
annotated_types-0.7.0.dist-info
anyio
anyio-4.10.0.dist-info
certifi
certifi-2025.8.3.dist-info
distro
distro-1.9.0.dist-info
_distutils_hack
distutils-precedence.pth
dotenv
h11
h11-0.16.0.dist-info
httpcore
httpcore-1.0.9.dist-info
httpx
httpx-0.28.1.dist-info
idna
idna-3.10.dist-info
iniconfig
iniconfig-2.1.0.dist-info
jiter
jiter-0.10.0.dist-info
openai
openai-1.102.0.dist-info
packaging
packaging-25.0.dist-info
pip
pip-23.0.1.dist-info
pkg_resources
pluggy
pluggy-1.6.0.dist-info
__pycache__
pydantic
pydantic-2.11.7.dist-info
pydantic_core
pydantic_core-2.33.2.dist-info
pygments
pygments-2.19.2.dist-info
py.py
_pytest
pytest
pytest-8.4.1.dist-info
python_dotenv-1.1.1.dist-info
setuptools
setuptools-66.1.1.dist-info
sniffio
sniffio-1.3.1.dist-info
tqdm
tqdm-4.67.1.dist-info
typing_extensions-4.15.0.dist-info
typing_extensions.py
typing_inspection
typing_inspection-0.4.1.dist-info

./azq_env/lib/python3.11/site-packages/annotated_types:
__init__.py
__pycache__
py.typed
test_cases.py

./azq_env/lib/python3.11/site-packages/annotated_types/__pycache__:
__init__.cpython-311.pyc
test_cases.cpython-311.pyc

./azq_env/lib/python3.11/site-packages/annotated_types-0.7.0.dist-info:
INSTALLER
licenses
METADATA
RECORD
WHEEL

./azq_env/lib/python3.11/site-packages/annotated_types-0.7.0.dist-info/licenses:
LICENSE

./azq_env/lib/python3.11/site-packages/anyio:
abc
_backends
_core
from_thread.py
__init__.py
lowlevel.py
__pycache__
pytest_plugin.py
py.typed
streams
to_interpreter.py
to_process.py
to_thread.py

./azq_env/lib/python3.11/site-packages/anyio/abc:
_eventloop.py
__init__.py
__pycache__
_resources.py
_sockets.py
_streams.py
_subprocesses.py
_tasks.py
_testing.py

./azq_env/lib/python3.11/site-packages/anyio/abc/__pycache__:
_eventloop.cpython-311.pyc
_eventloop.cpython-311-pytest-8.4.1.pyc
__init__.cpython-311.pyc
__init__.cpython-311-pytest-8.4.1.pyc
_resources.cpython-311.pyc
_resources.cpython-311-pytest-8.4.1.pyc
_sockets.cpython-311.pyc
_sockets.cpython-311-pytest-8.4.1.pyc
_streams.cpython-311.pyc
_streams.cpython-311-pytest-8.4.1.pyc
_subprocesses.cpython-311.pyc
_subprocesses.cpython-311-pytest-8.4.1.pyc
_tasks.cpython-311.pyc
_tasks.cpython-311-pytest-8.4.1.pyc
_testing.cpython-311.pyc
_testing.cpython-311-pytest-8.4.1.pyc

./azq_env/lib/python3.11/site-packages/anyio/_backends:
_asyncio.py
__init__.py
__pycache__
_trio.py

./azq_env/lib/python3.11/site-packages/anyio/_backends/__pycache__:
_asyncio.cpython-311.pyc
__init__.cpython-311.pyc
_trio.cpython-311.pyc

./azq_env/lib/python3.11/site-packages/anyio/_core:
_asyncio_selector_thread.py
_contextmanagers.py
_eventloop.py

## README.md
# azq — Ask ChatGPT from your terminal


## requirements.txt
openai
python-dotenv
pytest

