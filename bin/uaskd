#!/usr/bin/env python3
# uaskd â€” "because you asked" interactive command runner

import sys, subprocess

def run_command(cmd: str):
    """Run a shell command and stream its output + log it."""
    try:
        result = subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True)
        print(result.stdout)
        with open("logs/chatlog.md", "a") as f:
            f.write(f"\n[CMD] {cmd}\n")
            f.write(result.stdout)
    except subprocess.CalledProcessError as e:
        print(f"[uaskd] Command failed: {e}")
        with open("logs/chatlog.md", "a") as f:
            f.write(f"\n[CMD] {cmd} (FAILED)\n")
            f.write(e.stdout or "")
            f.write(e.stderr or "")

def interactive_prompt(commands):
    for cmd in commands:
        print(f"\nCommand suggested: {cmd}")
        while True:
            choice = input(
                "Run it? [y=Yes, s=Skip (default/Enter), e=Edit, p=Pause, a=Abort]: "
            ).strip().lower()

            if choice == "y":
                print(f"[uaskd] Running: {cmd}")
                run_command(cmd)
                break
            elif choice == "s" or choice == "":
                print("[uaskd] Skipped.")
                break
            elif choice == "e":
                edited = input("Edit command: ")
                if edited.strip():
                    print(f"[uaskd] Running edited: {edited}")
                    run_command(edited)
                break
            elif choice == "p":
                print("[uaskd] Paused. You can resume later.")
                return
            elif choice == "a":
                print("[uaskd] Aborted by user.")
                sys.exit(0)
            else:
                print("Invalid choice, please use y/s/e/p/a or Enter for skip.")

def main():
    if len(sys.argv) > 1:
        with open(sys.argv[1], "r") as f:
            text = f.read().splitlines()
    else:
        text = sys.stdin.read().splitlines()

    commands = []
    in_cmd_block = False

    for line in text:
        stripped = line.strip()

        # Our explicit markers
        if stripped == "::CMD":
            in_cmd_block = True
            continue
        if stripped == "::END_CMD":
            in_cmd_block = False
            continue

        if in_cmd_block and stripped:
            commands.append(stripped)
            continue

        # Fallback: catch "likely shell commands"
        if (
            stripped.startswith("git ")
            or stripped.startswith("./")
            or stripped.startswith("cd ")
            or stripped.startswith("ls ")
            or stripped.startswith("python ")
        ):
            commands.append(stripped.lstrip("!"))

    if not commands:
        print("[uaskd] No commands found in input.")
        return

    interactive_prompt(commands)






if __name__ == "__main__":
    main()

